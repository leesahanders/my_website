<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="NA">

<title>Lisa Anders - questionable.quarto - Deploying Data for Content On Connect</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title"><span class="icon-upper">LISA ANDERS</span><span class="icon-sep"></span><span class="icon-lower">questionable.quarto</span></span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-stuff" role="button" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-fa-database" role="img">
</i> 
 <span class="menu-text">Stuff</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-stuff">    
        <li>
    <a class="dropdown-item" href="https://questionable.quarto.pub/posts/">
 <span class="dropdown-text">Blog / Projects</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../lists.html">
 <span class="dropdown-text">Lists</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../presentations.html">
 <span class="dropdown-text">Presentations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://questionable.quarto.pub/recipes/">
 <span class="dropdown-text">Recipes</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../work.html">
 <span class="dropdown-text">Technical writeups</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../site_map.html"> 
<span class="menu-text">Site Map</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/leesahanders/my_website"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Deploying Data for Content On Connect</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Apps and reports on Connect usually rely on one or more data sets. Depending on the resources your organization has and the use case, it might make sense to store that data in a database, a flat file like a <code>csv</code>, or some other kind of interface.</p>
<p>This article will give an overview in terms of how to update data for an app or report on Connect.</p>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<table class="table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Data Method</th>
<th>Recommended use case</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Data in the App Bundle</strong></td>
<td>Data is updated as often or less often than the app code and doesn’t need to be shared across projects</td>
</tr>
<tr class="even">
<td><strong>Database</strong></td>
<td>Gold standard for data storage and access</td>
</tr>
<tr class="odd">
<td><strong>Pins</strong></td>
<td>Lightweight datasets, ephemeral data, models</td>
</tr>
<tr class="even">
<td><strong>Blob Storage</strong></td>
<td>Gold standard for storing large amounts of unstructured data</td>
</tr>
<tr class="odd">
<td><strong>Directory on Connect</strong></td>
<td>Typically the method of last resort for unstructured data as it requires SSH access to the server for setup and often requires code changes between development and deployment, however for very large files, it may be the only option</td>
</tr>
</tbody>
</table>
</section>
<section id="data-in-the-app-bundle" class="level2">
<h2 class="anchored" data-anchor-id="data-in-the-app-bundle">Data in the App Bundle</h2>
<p>If your data lives inside your app directory and is only updated as often as the app code, you can upload your data with your code and access it with a relative file path.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="bundled_data.drawio.svg" class="img-fluid figure-img" data-align="center"></p>
<figcaption>Data in the Connect Bundle</figcaption>
</figure>
</div>
<p>In this configuration, your code would access the data at the same relative path regardless of whether the code is being developed locally or is deployed to Connect.</p>
<p>The main limitation to including the data in the Connect bundle is that you must deploy everything (data and code) at the same time.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>If you update the data more often than the app code, use a different method.</p>
</div>
</div>
</section>
<section id="data-outside-the-app-bundle" class="level2">
<h2 class="anchored" data-anchor-id="data-outside-the-app-bundle">Data Outside the App Bundle</h2>
<p>If your data is updated more frequently than your app, the data can live in a database, in a pin on Connect, in a separate directory on Connect, or be accessed using other means.</p>
<section id="database" class="level3">
<h3 class="anchored" data-anchor-id="database">Database</h3>
<p>Apps, reports, and APIs on Connect can pull data from a live connection to a database.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="db_storage.drawio.svg" title="Live Database Connection" class="img-fluid figure-img" data-align="center"></p>
<figcaption>Live Database Connection</figcaption>
</figure>
</div>
<p>If you’re publishing an app or API, you might want all of the data pulled in at start up time or you might want a live connection that will pull data as input is received from the user.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Either of these patterns can work.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="db_data_init.drawio.svg" title="Pulling Data from a Database on Connect" class="img-fluid figure-img" data-align="center"></p>
<figcaption>Pulling Data from a Database on Connect</figcaption>
</figure>
</div>
<p>If you are pulling data directly from a database into a Shiny app, you’ll want to consider how you will protect your credentials. We have recommendations for these topics and more within our <a href="../db/">database best practices pages</a>.</p>
</section>
<section id="pins" class="level3">
<h3 class="anchored" data-anchor-id="pins">Pins</h3>
<p><a href="https://pins.rstudio.com">Pins</a> is an R package that allows for easy storage and retrieval of data, models, and other R objects. Pins can be a good choice when you don’t have write access to a database or when the data you’re trying to save is something like a model that won’t fit nicely into most databases.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="pins.drawio.svg" title="Using a Pin on Connect" class="img-fluid figure-img" data-align="center" width="389"></p>
<figcaption>Using a Pin on Connect</figcaption>
</figure>
</div>
<p>You can create a pin with the <code>pins::pin_write</code> command and retrieve the data with <code>pins::pin_read</code>. A major benefit of pins is that your code won’t have to change at all when you deploy – the read and write commands will work in both the IDE during development and on Connect.</p>
<p>The <a href="https://pins.rstudio.com">pins page</a> has more details on how to use pins.</p>
<p><a href="https://rviews.rstudio.com/2019/10/17/deploying-data-with-pins/">Here</a> is an example of how to use pins with either a Shiny app or Plumber API.</p>
</section>
<section id="blob-storage" class="level3">
<h3 class="anchored" data-anchor-id="blob-storage">Blob Storage</h3>
<p>Blob storage is the gold standard for storing unstructured data. It provides more options for access from developers compared to the challenges with file mounts experienced with traditional file storage. It comes with advantages over traditional file storage with low latency, integration with backup systems, and overall typically reduced cost.</p>
<p>Connection to your Blob storage is through forming the connection in your R or Python code, typically facilitated with a package. Common Blob storage providers include:</p>
<ul>
<li>Azure Blob Storage through <a href="https://cran.r-project.org/web/packages/AzureStor/">AzureStor</a> for R, <a href="https://pypi.org/project/azure-storage-blob/">azure-storage-blob</a> for Python</li>
<li>Google Cloud through <a href="https://cran.r-project.org/web/packages/googleCloudStorageR/">googleCloudStorageR</a> for R, <a href="https://pypi.org/project/google-cloud-storage/">google.cloud.storage</a> for Python</li>
<li>AWS S3 through <a href="https://cran.r-project.org/web/packages/aws.s3/">aws.s3</a> or <a href="https://paws-r.github.io/docs/s3/">PAWS</a> for R, <a href="https://pypi.org/project/boto3/">boto3</a> for Python</li>
</ul>
<p>Similar to when managing connections to a database you’ll want to consider how you will protect your credentials. We have recommendations within our <a href="../db/best-practices/managing-credentials/">securing credentials page</a>.</p>
</section>
<section id="directory-on-connect" class="level3">
<h3 class="anchored" data-anchor-id="directory-on-connect">Directory on Connect</h3>
<p>Content on Connect can use the server’s file system to store data. This option is usually a last resort because it requires SSH access to the server for setup, and often requires code changes between the IDE and Connect. For very large files, it may be the only option.</p>
<p>Content running on Connect is sandboxed within the server, so you must use an absolute path to access data, and must manually ensure that the relevant directory has the proper read/write permissions.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="persistent_storage.drawio.svg" title="Using Data from Persistent Storage on Connect" class="img-fluid figure-img" data-align="center" width="332"></p>
<figcaption>Using Data from Persistent Storage on Connect</figcaption>
</figure>
</div>
<p>One potential difficulty in using data from persistent storage is that the data path will probably change between the RStudio IDE and Connect, unless the directory is in the same location on both computers. You can <a href="https://support.posit.co/hc/en-us/articles/360007981134-Persistent-Storage-on-RStudio-Connect">use the <code>config</code> package</a> to have different paths in the development and deployed environment.</p>
</section>
<section id="other-methods-for-accessing-data" class="level3">
<h3 class="anchored" data-anchor-id="other-methods-for-accessing-data">Other Methods for Accessing Data</h3>
<p>Other sources of data can be integrated on a case by case basis. For example, for data stored in an external system often the developers will create an API through which data can be pulled.</p>
<p>Developers can interact directly with an API using packages such as <a href="https://httr.r-lib.org/">httr</a> and <a href="https://cran.r-project.org/web/packages/jsonlite/index.html">jsonlite</a> in R or <a href="https://pypi.org/project/requests/">requests</a> in Python. Developers can also build and deploy their own APIs for handling integrations, for example using <a href="https://www.rplumber.io/">Plumber</a> in R or <a href="https://flask.palletsprojects.com/en/2.2.x/">Flask</a> in Python, that can then be <a href="https://docs.posit.co/connect/user/accessing/">deployed and accessed on Connect</a>.</p>
<p>For some APIs, in order to make them more accessible, the interface is bundled as a package for developers to use. At the end of the day a lot of these systems are storing the data in blob storage under the hood. Some examples include <a href="https://github.com/Azure/Microsoft365R">Microsoft365R</a> and <a href="https://pypi.org/project/Office365-REST-Python-Client/">Office365-REST-Python-Client</a>(see our additional writeup <a href="../microsoft365/">here</a>), <a href="https://github.com/charlie86/spotifyr">spotifyr</a>, <a href="https://github.com/mkearney/rtweet">rtweet</a>, <a href="https://github.com/tidyverse/googlesheets4">googlesheets4</a> and <a href="https://pypi.org/project/PyDrive/">pydrive</a> and <a href="https://pypi.org/project/PyDrive2/">pydrive2</a>, <a href="https://github.com/karthik/rdrop2">rdrop2</a>, <a href="https://paws-r.github.io/">paws</a>, <a href="https://r-box.github.io/boxr/">boxr</a>, and many more.</p>
<p>For up to date information on the best practices for how to use a package see its documentation.</p>
</section>
</section>
<section id="special-considerations-for-shiny-apps" class="level2">
<h2 class="anchored" data-anchor-id="special-considerations-for-shiny-apps">Special Considerations for Shiny Apps</h2>
<section id="pre-cache-data-by-pulling-it-outside-the-shiny-app" class="level3">
<h3 class="anchored" data-anchor-id="pre-cache-data-by-pulling-it-outside-the-shiny-app">Pre-cache Data by Pulling it Outside the Shiny App</h3>
<p>If real time data isn’t critical then the data can be updated on some cadence using <a href="https://docs.posit.co/connect/user/scheduling/index.html">scheduled reports</a> and caching it to a location that the Shiny app is able to access. This is usually the biggest bang for the buck for drastically improving the performance and speed of your Shiny app. Set the cadence of the data pre-processing to be scheduled to coincide with how often you are expecting the data to change.</p>
</section>
<section id="pull-data-on-a-scheduler" class="level3">
<h3 class="anchored" data-anchor-id="pull-data-on-a-scheduler">Pull Data on a Scheduler</h3>
<p>Shiny apps work entirely on a “pull” model, so Shiny will need to check if the data is updated, as opposed to the new data “pushing” itself into the app.</p>
<p>If you want to write a general data-pulling function, <a href="https://shiny.posit.co/r/reference/shiny/latest/reactivepoll"><code>shiny::reactivePoll</code></a> allows you to periodically check a resource for changes and run an arbitrary function if it has. You can also use <a href="https://shiny.posit.co/r/reference/shiny/latest/invalidatelater"><code>shiny::invalidateLater</code></a> to invalidate a reactive on a schedule.</p>
<p>There are also several useful functions that are specially designed to schedule data refreshes. If you’re using a pin, <a href="https://pins.rstudio.com/reference/pin_reactive_read.html"><code>pins::pin_reactive_read()</code></a> allows you to check for updates to a pin on a schedule. Similarly, <a href="https://shiny.posit.co/r/reference/shiny/latest/reactivefilereader"><code>shiny::reactiveFileReader</code></a> allows you to check for updates to a file on persistent storage.</p>
</section>
<section id="speedy-data-loading" class="level3">
<h3 class="anchored" data-anchor-id="speedy-data-loading">Speedy data loading</h3>
<p>Regardless of how and where you load data, faster is always better. Some tips to speed load times for Shiny apps:</p>
<p><strong>Do less!</strong> Reducing the amount of data transmitted is the best way to reduce load times. Often, pre-aggregating data will prove sufficient for quick data loads.</p>
<p><strong>Use Shiny Scoping + Connect Settings</strong> Content outside a Shiny app’s <code>server</code> block (i.e.&nbsp;in <code>global</code>) will only be loaded once per <em>process</em> on Connect. Setting Connect’s <code>Min Processes</code> to 1 or greater will ensure that data is loaded before the first user arrives.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>How to close the connection when the content closes will depend on the content type. For example, you can register <a href="https://shiny.posit.co/r/reference/shiny/latest/onstop"><code>onStop</code></a> calls in Shiny, or an <a href="https://www.rplumber.io/reference/Plumber.html#method-">exit hook</a> in Plumber.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>The user who runs the content will need access. By default this is the <code>rstudio-connect</code> user. You can check which user a piece of content will run as under the <code>Access</code> tab on the content in Connect under <code>Who runs this content on the server</code>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Reactive content only runs inside Shiny server blocks. If you want to pre-load data <strong><em>and</em></strong> have the data respond to user input or reactive polling, you can load the data in the global context and then update it using the global assignment operator (<code>&lt;&lt;-</code>).<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>